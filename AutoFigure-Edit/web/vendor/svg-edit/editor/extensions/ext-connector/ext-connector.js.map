{"version":3,"mappings":"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","names":["startX","startY"],"ignoreList":[],"sources":["../../../../src/editor/extensions/ext-connector/ext-connector.js"],"sourcesContent":["/**\n * @file ext-connector.js\n *\n * @license MIT\n *\n * @copyright 2010 Alexis Deveria\n * @copyright 2023 Optimistik SAS\n *\n */\n\nconst name = 'connector'\n\nconst loadExtensionTranslation = async function (svgEditor) {\n  let translationModule\n  const lang = svgEditor.configObj.pref('lang')\n  try {\n    translationModule = await import(`./locale/${lang}.js`)\n  } catch (_error) {\n    // eslint-disable-next-line no-console\n    console.warn(`Missing translation (${lang}) for ${name} - using 'en'`)\n    translationModule = await import('./locale/en.js')\n  }\n  svgEditor.i18next.addResourceBundle(lang, name, translationModule.default)\n}\n\nexport default {\n  name,\n  async init (S) {\n    const svgEditor = this\n    const { svgCanvas } = svgEditor\n    const { getElement, $id, $click, addSVGElementsFromJson } = svgCanvas\n    const { svgroot, selectorManager } = S\n    const seNs = svgCanvas.getEditorNS()\n    await loadExtensionTranslation(svgEditor)\n\n    let startX\n    let startY\n    let curLine\n    let startElem\n    let endElem\n\n    let started = false\n    let connections = []\n\n    // Save the original groupSelectedElements method\n    const originalGroupSelectedElements = svgCanvas.groupSelectedElements\n\n    // Override the original groupSelectedElements to exclude connectors\n    svgCanvas.groupSelectedElements = function (...args) {\n      // Remove connectors from selection\n      svgCanvas.removeFromSelection(document.querySelectorAll('[id^=\"conn_\"]'))\n\n      // Call the original method\n      return originalGroupSelectedElements.apply(this, args)\n    }\n\n    // Save the original moveSelectedElements method\n    const originalMoveSelectedElements = svgCanvas.moveSelectedElements\n\n    // Override the original moveSelectedElements to handle connectors\n    svgCanvas.moveSelectedElements = function (...args) {\n      // Call the original method and store its result\n      const cmd = originalMoveSelectedElements.apply(this, args)\n\n      // Update connectors\n      updateConnectors(svgCanvas.getSelectedElements())\n\n      // Return the result of the original method\n      return cmd\n    }\n\n    /**\n     * getBBintersect\n     * @param {Float} x\n     * @param {Float} y\n     * @param {module:utilities.BBoxObject} bb\n     * @param {Float} offset\n     * @returns {module:math.XYObject}\n     */\n    const getBBintersect = (x, y, bb, offset) => {\n      // Adjust bounding box if offset is provided\n      if (offset) {\n        bb = { ...bb } // Create a shallow copy\n        bb.width += offset\n        bb.height += offset\n        bb.x -= offset / 2\n        bb.y -= offset / 2\n      }\n\n      // Calculate center of bounding box\n      const midX = bb.x + bb.width / 2\n      const midY = bb.y + bb.height / 2\n\n      // Calculate lengths from (x, y) to center\n      const lenX = x - midX\n      const lenY = y - midY\n\n      // Calculate slope of line from (x, y) to center\n      const slope = Math.abs(lenY / lenX)\n\n      // Calculate ratio to find intersection point\n      let ratio\n      if (slope < bb.height / bb.width) {\n        ratio = bb.width / 2 / Math.abs(lenX)\n      } else {\n        ratio = lenY ? bb.height / 2 / Math.abs(lenY) : 0\n      }\n\n      // Calculate intersection point\n      return {\n        x: midX + lenX * ratio,\n        y: midY + lenY * ratio\n      }\n    }\n\n    /**\n     * getOffset\n     * @param {\"start\"|\"end\"} side - The side of the line (\"start\" or \"end\") where the marker may be present.\n     * @param {Element} line - The line element to check for a marker.\n     * @returns {Float} - Returns the calculated offset if a marker is present, otherwise returns 0.\n     */\n    const getOffset = (side, line) => {\n      // Check for marker attribute on the given side (\"marker-start\" or \"marker-end\")\n      const hasMarker = line.getAttribute('marker-' + side)\n\n      // Calculate size based on stroke-width, multiplied by a constant factor (here, 5)\n      // TODO: This factor should ideally be based on the actual size of the marker.\n      const size = line.getAttribute('stroke-width') * 5\n\n      // Return calculated size if marker is present, otherwise return 0.\n      return hasMarker ? size : 0\n    }\n\n    /**\n     * showPanel\n     * @param {boolean} on - Determines whether to show or hide the elements.\n     * @returns {void}\n     */\n    const showPanel = on => {\n      // Find the 'connector_rules' or create it if it doesn't exist.\n      let connRules = $id('connector_rules')\n      if (!connRules) {\n        connRules = document.createElement('style')\n        connRules.setAttribute('id', 'connector_rules')\n        document.getElementsByTagName('head')[0].appendChild(connRules)\n      }\n\n      // Update the content of <style> element to either hide or show certain elements.\n      connRules.textContent = !on\n        ? ''\n        : '#tool_clone, #tool_topath, #tool_angle, #xy_panel { display: none !important; }'\n\n      // Update the display property of the <style> element itself based on the 'on' value.\n      if ($id('connector_rules')) {\n        $id('connector_rules').style.display = on ? 'block' : 'none'\n      }\n    }\n\n    /**\n     * setPoint\n     * @param {Element} elem - The SVG element.\n     * @param {Integer|\"end\"} pos - The position index or \"end\".\n     * @param {Float} x - The x-coordinate.\n     * @param {Float} y - The y-coordinate.\n     * @param {boolean} [setMid] - Whether to set the midpoint.\n     * @returns {void}\n     */\n    const setPoint = (elem, pos, x, y, setMid) => {\n      // Create a new SVG point\n      const pts = elem.points\n      const pt = svgroot.createSVGPoint()\n      pt.x = x\n      pt.y = y\n\n      // If position is \"end\", set it to the last index\n      if (pos === 'end') {\n        pos = pts.numberOfItems - 1\n      }\n\n      // Try replacing the point at the specified position\n      pts.replaceItem(pt, pos)\n\n      // Optionally, set the midpoint\n      if (setMid) {\n        const ptStart = pts.getItem(0)\n        const ptEnd = pts.getItem(pts.numberOfItems - 1)\n        setPoint(elem, 1, (ptEnd.x + ptStart.x) / 2, (ptEnd.y + ptStart.y) / 2)\n      }\n    }\n\n    /**\n     * @param {Float} diffX\n     * @param {Float} diffY\n     * @returns {void}\n     */\n    const updatePoints = (line, conn, bb, altBB, pre, altPre) => {\n      const srcX = altBB.x + altBB.width / 2\n      const srcY = altBB.y + altBB.height / 2\n\n      const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line))\n      setPoint(line, conn.is_start ? 0 : 'end', pt.x, pt.y, true)\n\n      const pt2 = getBBintersect(pt.x, pt.y, altBB, getOffset(altPre, line))\n      setPoint(line, conn.is_start ? 'end' : 0, pt2.x, pt2.y, true)\n    }\n\n    const updateLine = (diffX, diffY) => {\n      const dataStorage = svgCanvas.getDataStorage()\n\n      for (const conn of connections) {\n        const {\n          connector: line,\n          is_start: isStart,\n          start_x: startX,\n          start_y: startY\n        } = conn\n\n        const pre = isStart ? 'start' : 'end'\n        const altPre = isStart ? 'end' : 'start'\n\n        // Update bbox for this element\n        const bb = { ...dataStorage.get(line, `${pre}_bb`) }\n        bb.x = startX + diffX\n        bb.y = startY + diffY\n\n        dataStorage.put(line, `${pre}_bb`, bb)\n\n        // Get center point of connected element\n        const altBB = dataStorage.get(line, `${altPre}_bb`)\n\n        updatePoints(line, conn, bb, altBB, pre, altPre)\n      }\n    }\n\n    // Finds connectors associated with selected elements\n    const findConnectors = (elems = []) => {\n      // Fetch data storage object from svgCanvas\n      const dataStorage = svgCanvas.getDataStorage()\n\n      // Query all connector elements (id startss with conn_)\n      const connectors = document.querySelectorAll('[id^=\"conn_\"]')\n      // Reset connections array\n      connections = []\n\n      // Loop through each connector\n      for (const connector of connectors) {\n        let addThis = false // Flag to indicate whether to add this connector\n        const parts = [] // To hold the starting and ending elements connected by the connector\n\n        // Loop through the connector ends (\"start\" and \"end\")\n        for (const [i, pos] of ['start', 'end'].entries()) {\n          // Fetch connected element and its bounding box\n          let part = dataStorage.get(connector, `c_${pos}`)\n\n          // If part is null or undefined, fetch it and store it\n          if (!part) {\n            part = document.getElementById(\n              connector.attributes['se:connector'].value.split(' ')[i]\n            )\n            dataStorage.put(connector, `c_${pos}`, part.id)\n            dataStorage.put(\n              connector,\n              `${pos}_bb`,\n              svgCanvas.getStrokedBBox([part])\n            )\n          } else {\n            // If part is already stored, fetch it by ID\n            part = document.getElementById(part)\n          }\n\n          // Add the part to the parts array\n          parts.push(part)\n        }\n\n        // Loop through the starting and ending elements connected by the connector\n        for (let i = 0; i < 2; i++) {\n          const cElem = parts[i]\n          const parents = svgCanvas.getParents(cElem?.parentNode)\n\n          // Check if the element is part of a selected group\n          for (const el of parents) {\n            if (elems.includes(el)) {\n              addThis = true\n              break\n            }\n          }\n\n          // If element is missing or parent is null, remove the connector\n          if (!cElem || !cElem.parentNode) {\n            connector.remove()\n            continue\n          }\n\n          // If element is in the selection or part of a selected group\n          if (elems.includes(cElem) || addThis) {\n            const bb = svgCanvas.getStrokedBBox([cElem])\n\n            // Add connection information to the connections array\n            connections.push({\n              elem: cElem,\n              connector,\n              is_start: i === 0,\n              start_x: bb.x,\n              start_y: bb.y\n            })\n          }\n        }\n      }\n    }\n\n    /**\n     * Updates the connectors based on selected elements.\n     * @param {Element[]} [elems] - Optional array of selected elements.\n     * @returns {void}\n     */\n    const updateConnectors = elems => {\n      const dataStorage = svgCanvas.getDataStorage()\n\n      // Find connectors associated with selected elements\n      findConnectors(elems)\n\n      if (connections.length) {\n        // Iterate through each connection to update its state\n        for (const conn of connections) {\n          const {\n            elem,\n            connector: line,\n            is_start: isStart,\n            start_x: startX,\n            start_y: startY\n          } = conn\n\n          // Determine whether the connection starts or ends with this element\n          const pre = isStart ? 'start' : 'end'\n\n          // Update the bounding box for this element\n          const bb = svgCanvas.getStrokedBBox([elem])\n          bb.x = startX\n          bb.y = startY\n          dataStorage.put(line, `${pre}_bb`, bb)\n\n          // Determine the opposite end ('start' or 'end') of the connection\n          const altPre = isStart ? 'end' : 'start'\n\n          // Retrieve the bounding box for the connected element at the opposite end\n          const bb2 = dataStorage.get(line, `${altPre}_bb`)\n\n          // Calculate the center point of the connected element\n          const srcX = bb2?.x + bb2?.width / 2\n          const srcY = bb2?.y + bb2?.height / 2\n\n          // Update the point of the element being moved\n          const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line))\n          setPoint(line, isStart ? 0 : 'end', pt.x, pt.y, true)\n\n          // Update the point of the connected element at the opposite end\n          const pt2 = getBBintersect(\n            pt.x,\n            pt.y,\n            dataStorage.get(line, `${altPre}_bb`),\n            getOffset(altPre, line)\n          )\n          setPoint(line, isStart ? 'end' : 0, pt2.x, pt2.y, true)\n        }\n      }\n    }\n\n    /**\n     * Do on reset.\n     * @returns {void}\n     */\n    const reset = () => {\n      const dataStorage = svgCanvas.getDataStorage()\n      // Make sure all connectors have data set\n      const svgContent = svgCanvas.getSvgContent()\n      const elements = svgContent.querySelectorAll('*')\n      elements.forEach(element => {\n        const conn = element.getAttributeNS(seNs, 'connector')\n        if (conn) {\n          const connData = conn.split(' ')\n          const sbb = svgCanvas.getStrokedBBox([getElement(connData[0])])\n          const ebb = svgCanvas.getStrokedBBox([getElement(connData[1])])\n          dataStorage.put(element, 'c_start', connData[0])\n          dataStorage.put(element, 'c_end', connData[1])\n          dataStorage.put(element, 'start_bb', sbb)\n          dataStorage.put(element, 'end_bb', ebb)\n          svgCanvas.getEditorNS(true)\n        }\n      })\n    }\n\n    reset()\n\n    return {\n      name: svgEditor.i18next.t(`${name}:name`),\n      callback () {\n        // Add the button and its handler(s)\n        const buttonTemplate = document.createElement('template')\n        const title = `${name}:buttons.0.title`\n        buttonTemplate.innerHTML = `\n         <se-button id=\"tool_connect\" title=\"${title}\" src=\"conn.svg\"></se-button>\n         `\n        $id('tools_left').append(buttonTemplate.content.cloneNode(true))\n        $click($id('tool_connect'), () => {\n          if (this.leftPanel.updateLeftPanel('tool_connect')) {\n            svgCanvas.setMode('connector')\n          }\n        })\n      },\n      mouseDown (opts) {\n        // Retrieve necessary data from the SVG canvas and the event object\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n        const { event: e, start_x: startX, start_y: startY } = opts\n        const mode = svgCanvas.getMode()\n        const {\n          curConfig: { initStroke }\n        } = svgEditor.configObj\n\n        if (mode === 'connector') {\n          // Return if the line is already started\n          if (started) return undefined\n\n          const mouseTarget = e.target\n          const parents = svgCanvas.getParents(mouseTarget.parentNode)\n\n          // Check if the target is a child of the main SVG content\n          if (parents.includes(svgContent)) {\n            // Identify the connectable element, considering foreignObject elements\n            const fo = svgCanvas.getClosest(\n              mouseTarget.parentNode,\n              'foreignObject'\n            )\n            startElem = fo || mouseTarget\n\n            // Retrieve the bounding box and calculate the center of the start element\n            const bb = svgCanvas.getStrokedBBox([startElem])\n            const x = bb.x + bb.width / 2\n            const y = bb.y + bb.height / 2\n\n            // Set the flag to indicate the line has started\n            started = true\n\n            // Create a new polyline element\n            curLine = addSVGElementsFromJson({\n              element: 'polyline',\n              attr: {\n                id: 'conn_' + svgCanvas.getNextId(),\n                points: `${x},${y} ${x},${y} ${startX},${startY}`,\n                stroke: `#${initStroke.color}`,\n                'stroke-width':\n                  !startElem.stroke_width || startElem.stroke_width === 0\n                    ? initStroke.width\n                    : startElem.stroke_width,\n                fill: 'none',\n                opacity: initStroke.opacity,\n                style: 'pointer-events:none'\n              }\n            })\n\n            // Store the bounding box of the start element\n            dataStorage.put(curLine, 'start_bb', bb)\n          }\n\n          return {\n            started: true\n          }\n        }\n\n        if (mode === 'select') {\n          // Find connectors if the mode is 'select'\n          findConnectors(opts.selectedElements)\n        }\n\n        return undefined\n      },\n      mouseMove (opts) {\n        // Exit early if there are no connectors\n        if (connections.length === 0) return\n\n        const dataStorage = svgCanvas.getDataStorage()\n        const zoom = svgCanvas.getZoom()\n        // const e = opts.event;\n        const x = opts.mouse_x / zoom\n        const y = opts.mouse_y / zoom\n        /** @todo  We have a concern if startX or startY are undefined */\n        if (!startX || !startY) return\n\n        const diffX = x - startX\n        const diffY = y - startY\n\n        const mode = svgCanvas.getMode()\n        if (mode === 'connector' && started) {\n          // const sw = curLine.getAttribute('stroke-width') * 3;\n          // Set start point (adjusts based on bb)\n          const pt = getBBintersect(\n            x,\n            y,\n            dataStorage.get(curLine, 'start_bb'),\n            getOffset('start', curLine)\n          )\n          startX = pt.x\n          startY = pt.y\n\n          setPoint(curLine, 0, pt.x, pt.y, true)\n\n          // Set end point\n          setPoint(curLine, 'end', x, y, true)\n        } else if (mode === 'select') {\n          for (const elem of svgCanvas.getSelectedElements()) {\n            if (elem && dataStorage.has(elem, 'c_start')) {\n              svgCanvas.removeFromSelection([elem])\n              elem.transform.baseVal.clear()\n            }\n          }\n          if (connections.length) {\n            updateLine(diffX, diffY)\n          }\n        }\n      },\n      mouseUp (opts) {\n        // Get necessary data and initial setups\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n        const { event: e } = opts\n        let mouseTarget = e.target\n\n        // Early exit if not in connector mode\n        if (svgCanvas.getMode() !== 'connector') return undefined\n\n        // Check for a foreignObject parent and update mouseTarget if found\n        const fo = svgCanvas.getClosest(mouseTarget.parentNode, 'foreignObject')\n        if (fo) mouseTarget = fo\n\n        // Check if the target is a child of the main SVG content\n        const parents = svgCanvas.getParents(mouseTarget.parentNode)\n        const isInSvgContent = parents.includes(svgContent)\n\n        if (mouseTarget === startElem) {\n          // Case: Started drawing line via click\n          started = true\n          return {\n            keep: true,\n            element: null,\n            started\n          }\n        }\n\n        if (!isInSvgContent) {\n          // Case: Invalid target element; remove the line\n          curLine?.remove()\n          started = false\n          return {\n            keep: false,\n            element: null,\n            started\n          }\n        }\n\n        // Valid target element for the end of the line\n        endElem = mouseTarget\n\n        const startId = startElem?.id || ''\n        const endId = endElem?.id || ''\n        const connStr = `${startId} ${endId}`\n        const altStr = `${endId} ${startId}`\n\n        // Prevent duplicate connectors\n        const dupe = Array.from(\n          document.querySelectorAll('[id^=\"conn_\"]')\n        ).filter(\n          conn =>\n            conn.getAttributeNS(seNs, 'connector') === connStr ||\n            conn.getAttributeNS(seNs, 'connector') === altStr\n        )\n\n        if (dupe.length) {\n          curLine.remove()\n          return {\n            keep: false,\n            element: null,\n            started: false\n          }\n        }\n\n        // Update the end point of the connector\n        const bb = svgCanvas.getStrokedBBox([endElem])\n        const pt = getBBintersect(\n          startX,\n          startY,\n          bb,\n          getOffset('start', curLine)\n        )\n        setPoint(curLine, 'end', pt.x, pt.y, true)\n\n        // Save metadata to the connector\n        dataStorage.put(curLine, 'c_start', startId)\n        dataStorage.put(curLine, 'c_end', endId)\n        dataStorage.put(curLine, 'end_bb', bb)\n        curLine.setAttributeNS(seNs, 'se:connector', connStr)\n        curLine.setAttribute('opacity', 1)\n\n        // Finalize the connector\n        svgCanvas.addToSelection([curLine])\n        svgCanvas.moveToBottomSelectedElement()\n        selectorManager.requestSelector(curLine).showGrips(false)\n\n        started = false\n        return {\n          keep: true,\n          element: curLine,\n          started\n        }\n      },\n      selectedChanged (opts) {\n        // Get necessary data storage and SVG content\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n\n        // Exit early if there are no connectors\n        if (!svgContent.querySelectorAll('[id^=\"conn_\"]').length) return\n\n        // If the current mode is 'connector', switch to 'select'\n        if (svgCanvas.getMode() === 'connector') {\n          svgCanvas.setMode('select')\n        }\n\n        // Get currently selected elements\n        const { elems: selElems } = opts\n\n        // Iterate through selected elements\n        for (const elem of selElems) {\n          // If the element has a connector start, handle it\n          if (elem && dataStorage.has(elem, 'c_start')) {\n            selectorManager.requestSelector(elem).showGrips(false)\n\n            // Show panel depending on selection state\n            showPanel(opts.selectedElement && !opts.multiselected)\n          } else {\n            // Hide panel if no connector start\n            showPanel(false)\n          }\n        }\n\n        // Update connectors based on selected elements\n        updateConnectors(svgCanvas.getSelectedElements())\n      },\n      elementChanged (opts) {\n        // Get the necessary data storage\n        const dataStorage = svgCanvas.getDataStorage()\n\n        // Get the first element from the options; exit early if it's null\n        let [elem] = opts.elems\n        if (!elem) return\n\n        // Reinitialize if it's the main SVG content\n        if (elem.tagName === 'svg' && elem.id === 'svgcontent') {\n          reset()\n        }\n\n        // Check for marker attributes and update offsets\n        const { markerStart, markerMid, markerEnd } = elem.attributes\n        if (markerStart || markerMid || markerEnd) {\n          curLine = elem\n          dataStorage.put(elem, 'start_off', Boolean(markerStart))\n          dataStorage.put(elem, 'end_off', Boolean(markerEnd))\n\n          // Convert lines to polyline if there's a mid-marker\n          if (elem.tagName === 'line' && markerMid) {\n            const { x1, x2, y1, y2, id } = elem.attributes\n\n            const midPt = `${(Number(x1.value) + Number(x2.value)) / 2},${\n              (Number(y1.value) + Number(y2.value)) / 2\n            }`\n            const pline = addSVGElementsFromJson({\n              element: 'polyline',\n              attr: {\n                points: `${x1.value},${y1.value} ${midPt} ${x2.value},${y2.value}`,\n                stroke: elem.getAttribute('stroke'),\n                'stroke-width': elem.getAttribute('stroke-width'),\n                'marker-mid': markerMid.value,\n                fill: 'none',\n                opacity: elem.getAttribute('opacity') || 1\n              }\n            })\n\n            elem.insertAdjacentElement('afterend', pline)\n            elem.remove()\n            svgCanvas.clearSelection()\n            pline.id = id.value\n            svgCanvas.addToSelection([pline])\n            elem = pline\n          }\n        }\n\n        // Update connectors based on the current element\n        if (elem?.id.startsWith('conn_')) {\n          const start = getElement(dataStorage.get(elem, 'c_start'))\n          updateConnectors([start])\n        } else {\n          updateConnectors(svgCanvas.getSelectedElements())\n        }\n      },\n      IDsUpdated (input) {\n        const remove = []\n        input.elems.forEach(function (elem) {\n          if ('se:connector' in elem.attr) {\n            elem.attr['se:connector'] = elem.attr['se:connector']\n              .split(' ')\n              .map(function (oldID) {\n                return input.changes[oldID]\n              })\n              .join(' ')\n\n            // Check validity - the field would be something like 'svg_21 svg_22', but\n            // if one end is missing, it would be 'svg_21' and therefore fail this test\n            if (!/. ./.test(elem.attr['se:connector'])) {\n              remove.push(elem.attr.id)\n            }\n          }\n        })\n        return { remove }\n      },\n      toolButtonStateUpdate (opts) {\n        const button = document.getElementById('tool_connect')\n        if (opts.nostroke && button.pressed === true) {\n          svgEditor.clickSelect()\n        }\n        button.disabled = opts.nostroke\n      }\n    }\n  }\n}\n"],"file":"ext-connector.js"}